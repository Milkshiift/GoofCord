import ts from "typescript";
import path from "node:path";
import { Glob } from "bun";

function isNodeExported(node: ts.Node): boolean {
	return (
		// @ts-ignore
		node.modifiers?.some(
			(modifier: { kind: ts.SyntaxKind; }) => modifier.kind === ts.SyntaxKind.ExportKeyword
		) ?? false
	);
}

function isTsFunctionAsync(node: ts.FunctionDeclaration, sourceFile: ts.SourceFile): boolean {
    if (node.modifiers?.some(mod => mod.kind === ts.SyntaxKind.AsyncKeyword)) {
        return true;
    }
    if (node.type) {
        const returnTypeText = node.type.getText(sourceFile);
        if (returnTypeText.startsWith("Promise<") || returnTypeText === "Promise") {
            return true;
        }
    }
    return false;
}

function generateHandleHandler(channelName: string, funcName: string, parameters: string, isAsync: boolean): string {
	if (isAsync) {
		return `ipcMain.handle("${channelName}", async (event, ${parameters}) => { return await ${funcName}(${parameters}); });`;
	} else {
		return `ipcMain.handle("${channelName}", (event, ${parameters}) => { return ${funcName}(${parameters}); });`;
	}
}

function generateOnHandler(channelName: string, funcName: string, parameters: string, isAsync: boolean): string {
	if (isAsync) {
		return `ipcMain.on("${channelName}", async (event, ${parameters}) => { event.returnValue = await ${funcName}(${parameters}); });`;
	} else {
		return `ipcMain.on("${channelName}", (event, ${parameters}) => { event.returnValue = ${funcName}(${parameters}); });`;
	}
}

export async function genIpcHandlers() {
	const ipcGenFilePath = "./src/ipcGen.ts";
	const ipcGenFileAbsolutePath = path.resolve(ipcGenFilePath);
	const initialContent = "// This file is auto-generated by genIpcHandlers, any changes will be lost\n";

  const srcRoot = "./src";
	const filePattern = new Glob("**/*.ts");
	const discoveredFilePaths: string[] = [];

	for await (const fileRelative_to_srcRoot of filePattern.scan({ cwd: srcRoot, absolute: false, onlyFiles: true })) {
  	const projectRelativePath = path.join(srcRoot, fileRelative_to_srcRoot);
  	const absolutePath = path.resolve(projectRelativePath);

  	if (!projectRelativePath.endsWith(".d.ts") && absolutePath !== ipcGenFileAbsolutePath) {
  	    discoveredFilePaths.push(projectRelativePath);
  	}
	}

	const program = ts.createProgram(discoveredFilePaths, {
		target: ts.ScriptTarget.ESNext,
		module: ts.ModuleKind.CommonJS,
        allowJs: true,
	});

  const resolvedDiscoveredPathsSet = new Set(discoveredFilePaths.map(p => path.resolve(p)));
	const sourceFilesToProcess = program.getSourceFiles().filter(sf =>
        !sf.isDeclarationFile && resolvedDiscoveredPathsSet.has(path.resolve(sf.fileName))
    );

	const collectedImports = new Map<string, Set<string>>();
	const handlerStatements: string[] = [];

	for (const sourceFile of sourceFilesToProcess) {
		const filename = path.basename(sourceFile.fileName, path.extname(sourceFile.fileName));

		ts.forEachChild(sourceFile, (node) => {
			if (ts.isFunctionDeclaration(node) && node.name && isNodeExported(node)) {
				const funcName = node.name.getText(sourceFile);

				const typeParametersString = node.typeParameters?.map((tp) => tp.getText(sourceFile)).join(", ") ?? "";

				if (typeParametersString.includes("IPC")) {
					const parameters = node.parameters
						.map((param) => param.name.getText(sourceFile))
						.join(", ");
					const channelName = `${filename}:${funcName}`;
					const isAsync = isTsFunctionAsync(node, sourceFile);

					if (typeParametersString.includes("IPCHandle")) {
						handlerStatements.push(
							generateHandleHandler(channelName, funcName, parameters, isAsync)
						);
					} else if (typeParametersString.includes("IPCOn")) {
						handlerStatements.push(
							generateOnHandler(channelName, funcName, parameters, isAsync)
						);
					} else {
            return;
          }

          const ipcGenDir = path.dirname(ipcGenFileAbsolutePath);

          let relativeImportPath = path.relative(ipcGenDir, sourceFile.fileName);
          relativeImportPath = relativeImportPath.replace(/\\/g, "/").replace(/\.(ts|js|tsx|jsx)$/, "");
          if (!relativeImportPath.startsWith(".")) {
              relativeImportPath = "./" + relativeImportPath;
          }

					if (!collectedImports.has(relativeImportPath)) {
						collectedImports.set(relativeImportPath, new Set());
					}
					collectedImports.get(relativeImportPath)!.add(funcName);
				}
			}
		});
	}

  let output = initialContent;
  output += `import { ipcMain } from "electron";\n`;

  for (const [moduleSpecifier, namedImports] of collectedImports) {
      output += `import { ${Array.from(namedImports).join(", ")} } from "${moduleSpecifier}";\n`;
  }

  output += "\n";
  output += handlerStatements.join("\n");

	await Bun.write(ipcGenFilePath, output);
}
