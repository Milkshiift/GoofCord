import ts from "typescript";
import path from "node:path";
import { Glob } from "bun";

function isNodeExported(node: ts.FunctionDeclaration): boolean {
	return (
		// @ts-ignore
		node.modifiers?.some((modifier) => modifier.kind === ts.SyntaxKind.ExportKeyword) ?? false
	);
}

function isTsFunctionAsync(node: ts.FunctionDeclaration, sourceFile: ts.SourceFile): boolean {
	if (node.modifiers?.some((mod) => mod.kind === ts.SyntaxKind.AsyncKeyword)) {
		return true;
	}
	if (node.type) {
		const returnTypeText = node.type.getText(sourceFile);
		if (returnTypeText.startsWith("Promise<") || returnTypeText === "Promise") {
			return true;
		}
	}
	return false;
}

function generateHandler(channelName: string, funcName: string, parameters: string, isAsync: boolean, type: "handle" | "on"): string {
	const prefix = type === "handle" ? "ipcMain.handle" : "ipcMain.on";
	const body = type === "handle"
		? (isAsync ? `return await ${funcName}(${parameters});` : `return ${funcName}(${parameters});`)
		: (isAsync ? `event.returnValue = await ${funcName}(${parameters});` : `event.returnValue = ${funcName}(${parameters});`);

	const asyncKw = isAsync ? "async " : "";
	return `${prefix}("${channelName}", ${asyncKw}(event, ${parameters}) => { ${body} });`;
}

export async function genIpcHandlers() {
	const ipcGenFilePath = "./src/ipcGen.ts";
	const ipcGenFileAbsolutePath = path.resolve(ipcGenFilePath);
	const ipcGenDir = path.dirname(ipcGenFileAbsolutePath);

	const srcRoot = "./src";
	const filePattern = new Glob("**/*.ts");

	const allFilePaths: string[] = [];
	for await (const fileRelative of filePattern.scan({ cwd: srcRoot, absolute: false, onlyFiles: true })) {
		allFilePaths.push(path.join(srcRoot, fileRelative));
	}

	const results = await Promise.all(allFilePaths.map(async (filePath) => {
		const absolutePath = path.resolve(filePath);

		if (filePath.endsWith(".d.ts") || absolutePath === ipcGenFileAbsolutePath) return null;

		const content = await Bun.file(absolutePath).text();

		if (!content.includes("IPC")) return null;

		const sourceFile = ts.createSourceFile(
			absolutePath,
			content,
			ts.ScriptTarget.ESNext,
			true
		);

		const fileImports = new Set<string>();
		const fileHandlers: string[] = [];
		const filename = path.basename(sourceFile.fileName, path.extname(sourceFile.fileName));

		ts.forEachChild(sourceFile, (node) => {
			if (ts.isFunctionDeclaration(node) && node.name && isNodeExported(node)) {
				if (!node.typeParameters || node.typeParameters.length === 0) return;

				const typeParametersString = node.typeParameters.map((tp) => tp.getText(sourceFile)).join(", ");

				if (typeParametersString.includes("IPC")) {
					const funcName = node.name.getText(sourceFile);
					const parameters = node.parameters.map((param) => param.name.getText(sourceFile)).join(", ");
					const channelName = `${filename}:${funcName}`;
					const isAsync = isTsFunctionAsync(node, sourceFile);

					if (typeParametersString.includes("IPCHandle")) {
						fileHandlers.push(generateHandler(channelName, funcName, parameters, isAsync, "handle"));
					} else if (typeParametersString.includes("IPCOn")) {
						fileHandlers.push(generateHandler(channelName, funcName, parameters, isAsync, "on"));
					} else {
						return;
					}

					let relativeImportPath = path.relative(ipcGenDir, sourceFile.fileName);
					relativeImportPath = relativeImportPath.replace(/\\/g, "/").replace(/\.(ts|js|tsx|jsx)$/, "");
					if (!relativeImportPath.startsWith(".")) {
						relativeImportPath = "./" + relativeImportPath;
					}

					fileImports.add(`${relativeImportPath}::${funcName}`);
				}
			}
		});

		return { handlers: fileHandlers, imports: fileImports };
	}));

	const collectedImports = new Map<string, Set<string>>();
	const handlerStatements: string[] = [];

	for (const result of results) {
		if (!result) continue;

		handlerStatements.push(...result.handlers);

		for (const importStr of result.imports) {
			const [pathStr, funcName] = importStr.split("::");
			if (!collectedImports.has(pathStr)) {
				collectedImports.set(pathStr, new Set());
			}
			collectedImports.get(pathStr)!.add(funcName);
		}
	}

	let output = "// This file is auto-generated by genIpcHandlers, any changes will be lost\n";
	output += `import { ipcMain } from "electron";\n`;

	const sortedPaths = Array.from(collectedImports.keys()).sort();
	for (const moduleSpecifier of sortedPaths) {
		const namedImports = Array.from(collectedImports.get(moduleSpecifier)!).sort().join(", ");
		output += `import { ${namedImports} } from "${moduleSpecifier}";\n`;
	}

	output += "\n";
	output += handlerStatements.join("\n");

	await Bun.write(ipcGenFilePath, output);
}