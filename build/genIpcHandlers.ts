import path from "node:path";
import { Glob } from "bun";
import ts from "typescript";

interface IpcFunctionInfo {
	channelName: string;
	funcName: string;
	parameters: string;
	isAsync: boolean;
	type: "handle" | "on";
	importPath: string;
	returnType?: string;
	paramTypes: Array<{ name: string; type: string }>;
}

interface RegistryHandler {
	channelName: string;
	funcSignature: string;
	type: "handle" | "on";
}

interface GeneratorConfig {
	ipcDir: string;
	srcRoot: string;
	filePattern: string;
	skipPatterns?: string[];
}

const DEFAULT_CONFIG: GeneratorConfig = {
	ipcDir: "./src/ipc",
	srcRoot: "./src",
	filePattern: "**/*.ts",
	skipPatterns: [".d.ts", ".test.ts", ".spec.ts"],
};

// Validation & Error Handling

class IpcGeneratorError extends Error {
	constructor(
		message: string,
		public filePath?: string,
	) {
		super(message);
		this.name = "IpcGeneratorError";
	}
}

function validateChannelName(channelName: string, filePath: string): void {
	if (!channelName || channelName.trim() === "") {
		throw new IpcGeneratorError(`Invalid empty channel name in ${filePath}`);
	}
	if (channelName.includes(" ") || channelName.includes("\n")) {
		throw new IpcGeneratorError(`Channel name cannot contain whitespace: "${channelName}" in ${filePath}`);
	}
}

// Type Extraction

function isNodeExported(node: ts.FunctionDeclaration): boolean {
	return node.modifiers?.some((m) => m.kind === ts.SyntaxKind.ExportKeyword) ?? false;
}

function isTsFunctionAsync(node: ts.FunctionDeclaration, sourceFile: ts.SourceFile): boolean {
	if (node.modifiers?.some((m) => m.kind === ts.SyntaxKind.AsyncKeyword)) {
		return true;
	}

	if (node.type) {
		const returnTypeText = node.type.getText(sourceFile);
		if (returnTypeText.startsWith("Promise<") || returnTypeText === "Promise") {
			return true;
		}
	}

	return false;
}

function extractParameterInfo(param: ts.ParameterDeclaration, sourceFile: ts.SourceFile) {
	const name = param.name.getText(sourceFile);
	let type = "any";

	if (param.type) {
		type = param.type.getText(sourceFile);
	} else if (param.initializer) {
		const initText = param.initializer.getText(sourceFile);
		if (initText === "true" || initText === "false") type = "boolean";
		else if (!Number.isNaN(Number(initText))) type = "number";
		else if (initText.startsWith('"') || initText.startsWith("'")) type = "string";
	}

	return { name, type };
}

function extractReturnType(node: ts.FunctionDeclaration, sourceFile: ts.SourceFile): string {
	if (node.type) {
		return node.type.getText(sourceFile);
	}
	return "void";
}

// Code Generation

function generateHandler(channelName: string, funcName: string, parameters: string, isAsync: boolean, type: "handle" | "on"): string {
	const prefix = type === "handle" ? "ipcMain.handle" : "ipcMain.on";
	const asyncKw = isAsync ? "async " : "";
	const awaitKw = isAsync ? "await " : "";

	const body = type === "handle" ? `return ${awaitKw}${funcName}(${parameters});` : `event.returnValue = ${awaitKw}${funcName}(${parameters});`;

	const params = parameters ? `, ${parameters}` : "";
	return `${prefix}("${channelName}", ${asyncKw}(event${params}) => { ${body} });`;
}

function generateHandlerFile(functions: IpcFunctionInfo[], collectedImports: Map<string, Set<string>>, sortedPaths: string[]): string {
	const lines: string[] = ["// This file is auto-generated by genIpcHandlers, any changes will be lost", "", 'import { ipcMain } from "electron";'];

	for (const moduleSpecifier of sortedPaths) {
		const imports = collectedImports.get(moduleSpecifier);
		if (!imports) {
			throw new Error(`Imports for ${moduleSpecifier} unexpectedly missing`);
		}
		const namedImports = Array.from(imports).sort().join(", ");
		lines.push(`import { ${namedImports} } from "${moduleSpecifier}";`);
	}

	if (sortedPaths.length > 0) {
		lines.push("");
	}

	lines.push("export function registerAllHandlers() {");

	for (const func of functions) {
		const handler = generateHandler(func.channelName, func.funcName, func.parameters, func.isAsync, func.type);
		lines.push(`  ${handler}`);
	}

	lines.push("}");

	return lines.join("\n") + "\n";
}

function generateTypesFile(functions: IpcFunctionInfo[], registryHandlers: RegistryHandler[], collectedImports: Map<string, Set<string>>, sortedPaths: string[]): string {
	const lines: string[] = ["// This file is auto-generated by genIpcHandlers, any changes will be lost", ""];

	if (sortedPaths.length > 0) {
		for (const moduleSpecifier of sortedPaths) {
			const imports = collectedImports.get(moduleSpecifier);
			if (!imports) {
				throw new Error(`Imports for ${moduleSpecifier} unexpectedly missing`);
			}
			const namedImports = Array.from(imports).sort().join(", ");
			lines.push(`import type { ${namedImports} } from "${moduleSpecifier}";`);
		}
		lines.push("");
	}

	const handleFunctions = functions.filter((f) => f.type === "handle");
	const onFunctions = functions.filter((f) => f.type === "on");
	const registryHandleFunctions = registryHandlers.filter((h) => h.type === "handle");
	const registryOnFunctions = registryHandlers.filter((h) => h.type === "on");

	lines.push("export interface IpcHandleChannels {");
	for (const func of handleFunctions) {
		lines.push(`  "${func.channelName}": typeof ${func.funcName};`);
	}
	lines.push("}", "");

	lines.push("export interface IpcOnChannels {");
	for (const func of onFunctions) {
		lines.push(`  "${func.channelName}": typeof ${func.funcName};`);
	}
	lines.push("}", "");

	lines.push("export interface RegisteredIpcHandleChannels {");
	for (const handler of registryHandleFunctions) {
		lines.push(`  "${handler.channelName}": ${handler.funcSignature};`);
	}
	lines.push("}", "");

	lines.push("export interface RegisteredIpcOnChannels {");
	for (const handler of registryOnFunctions) {
		lines.push(`  "${handler.channelName}": ${handler.funcSignature};`);
	}
	lines.push("}", "");

	lines.push(
		"export type AllIpcHandleChannels = IpcHandleChannels & RegisteredIpcHandleChannels;",
		"export type AllIpcOnChannels = IpcOnChannels & RegisteredIpcOnChannels;",
		"export type AllIpcChannels = AllIpcHandleChannels & AllIpcOnChannels;",
		"",
		"export type IpcHandleChannel = keyof AllIpcHandleChannels;",
		"export type IpcOnChannel = keyof AllIpcOnChannels;",
		"export type IpcChannel = keyof AllIpcChannels;",
		"",
		"export type IpcParams<T extends IpcChannel> = Parameters<AllIpcChannels[T]>;",
		"export type IpcReturn<T extends IpcChannel> = ReturnType<AllIpcChannels[T]>;",
		"",
		"// Utility type for awaited return values",
		"export type IpcReturnAwaited<T extends IpcChannel> = Awaited<IpcReturn<T>>;",
	);

	return lines.join("\n") + "\n";
}

// Extraction Functions

function extractRegistryHandlers(sourceFile: ts.SourceFile): RegistryHandler[] {
	const handlers: RegistryHandler[] = [];

	function visit(node: ts.Node) {
		if (!ts.isCallExpression(node) || !ts.isIdentifier(node.expression)) {
			ts.forEachChild(node, visit);
			return;
		}

		const funcName = node.expression.text;
		if (funcName !== "registerHandle" && funcName !== "registerOn") {
			ts.forEachChild(node, visit);
			return;
		}

		const [channelArg, handlerArg] = node.arguments;

		if (!ts.isStringLiteral(channelArg) || !handlerArg) {
			ts.forEachChild(node, visit);
			return;
		}

		const channelName = channelArg.text;
		let funcSignature = "() => void";

		if (ts.isArrowFunction(handlerArg) || ts.isFunctionExpression(handlerArg)) {
			const parameters = Array.from(handlerArg.parameters);
			const firstParam = parameters[0];

			let paramsToUse = parameters;
			if (firstParam) {
				const firstName = firstParam.name.getText(sourceFile);
				const isEventParam = firstName === "event" || firstName === "_event" || (firstParam.type && /IpcMain(Event|InvokeEvent)/.test(firstParam.type.getText(sourceFile)));

				if (isEventParam) {
					paramsToUse = parameters.slice(1);
				}
			}

			const params = paramsToUse
				.map((p) => {
					const name = p.name.getText(sourceFile);
					const type = p.type ? p.type.getText(sourceFile) : "any";
					return `${name}: ${type}`;
				})
				.join(", ");

			const returnType = handlerArg.type ? handlerArg.type.getText(sourceFile) : "void";
			funcSignature = `(${params}) => ${returnType}`;
		}

		handlers.push({
			channelName,
			funcSignature,
			type: funcName === "registerHandle" ? "handle" : "on",
		});

		ts.forEachChild(node, visit);
	}

	visit(sourceFile);
	return handlers;
}

function extractIpcFunctions(sourceFile: ts.SourceFile, ipcGenDir: string): { functions: IpcFunctionInfo[]; imports: Set<string> } {
	const functions: IpcFunctionInfo[] = [];
	const imports = new Set<string>();
	const filename = path.basename(sourceFile.fileName, path.extname(sourceFile.fileName));

	ts.forEachChild(sourceFile, (node) => {
		if (!ts.isFunctionDeclaration(node) || !node.name || !isNodeExported(node)) {
			return;
		}

		if (!node.typeParameters || node.typeParameters.length === 0) return;

		const typeParametersString = node.typeParameters.map((tp) => tp.getText(sourceFile)).join(", ");

		if (!typeParametersString.includes("IPC")) return;

		let type: "handle" | "on" | null = null;
		if (typeParametersString.includes("IPCHandle")) {
			type = "handle";
		} else if (typeParametersString.includes("IPCOn")) {
			type = "on";
		}

		if (!type) return;

		const funcName = node.name.getText(sourceFile);
		const channelName = `${filename}:${funcName}`;

		validateChannelName(channelName, sourceFile.fileName);

		const paramTypes = node.parameters.map((p) => extractParameterInfo(p, sourceFile));
		const parameters = paramTypes.map((p) => p.name).join(", ");
		const isAsync = isTsFunctionAsync(node, sourceFile);
		const returnType = extractReturnType(node, sourceFile);

		let relativeImportPath = path.relative(ipcGenDir, sourceFile.fileName);
		relativeImportPath = relativeImportPath.replace(/\\/g, "/").replace(/\.(ts|js|tsx|jsx)$/, "");

		if (!relativeImportPath.startsWith(".")) {
			relativeImportPath = "./" + relativeImportPath;
		}

		functions.push({
			channelName,
			funcName,
			parameters,
			isAsync,
			type,
			importPath: relativeImportPath,
			returnType,
			paramTypes,
		});

		imports.add(`${relativeImportPath}::${funcName}`);
	});

	return { functions, imports };
}

// Main Generator

export async function genIpcHandlers(config: Partial<GeneratorConfig> = {}) {
	const cfg = { ...DEFAULT_CONFIG, ...config };

	const ipcGenFilePath = `${cfg.ipcDir}/gen.ts`;
	const ipcTypesFilePath = `${cfg.ipcDir}/types.ts`;
	const ipcRegistryFilePath = `${cfg.ipcDir}/registry.ts`;
	const ipcClientFilePath = `${cfg.ipcDir}/client.ts`;

	const ipcGenFileAbsolutePath = path.resolve(ipcGenFilePath);
	const ipcTypesFileAbsolutePath = path.resolve(ipcTypesFilePath);
	const ipcRegistryFileAbsolutePath = path.resolve(ipcRegistryFilePath);
	const ipcClientFileAbsolutePath = path.resolve(ipcClientFilePath);
	const ipcGenDir = path.dirname(ipcGenFileAbsolutePath);

	const filePattern = new Glob(cfg.filePattern);
	const skipPatterns = cfg.skipPatterns || [];

	const allFilePaths: string[] = [];
	for await (const fileRelative of filePattern.scan({
		cwd: cfg.srcRoot,
		absolute: false,
		onlyFiles: true,
	})) {
		if (skipPatterns.some((pattern) => fileRelative.endsWith(pattern))) {
			continue;
		}
		allFilePaths.push(path.join(cfg.srcRoot, fileRelative));
	}

	allFilePaths.sort();

	const allFunctions: IpcFunctionInfo[] = [];
	const allRegistryHandlers: RegistryHandler[] = [];
	const collectedImports = new Map<string, Set<string>>();
	const errors: IpcGeneratorError[] = [];

	await Promise.all(
		allFilePaths.map(async (filePath) => {
			try {
				const absolutePath = path.resolve(filePath);

				if (absolutePath === ipcGenFileAbsolutePath || absolutePath === ipcTypesFileAbsolutePath || absolutePath === ipcRegistryFileAbsolutePath || absolutePath === ipcClientFileAbsolutePath) {
					return;
				}

				const content = await Bun.file(absolutePath).text();

				const hasIpcMarker = content.includes("IPC");
				const hasRegister = content.includes("registerHandle") || content.includes("registerOn");

				if (!hasIpcMarker && !hasRegister) return;

				const sourceFile = ts.createSourceFile(absolutePath, content, ts.ScriptTarget.ESNext, true);

				if (hasRegister) {
					const registryHandlers = extractRegistryHandlers(sourceFile);
					allRegistryHandlers.push(...registryHandlers);
				}

				if (hasIpcMarker) {
					const { functions, imports } = extractIpcFunctions(sourceFile, ipcGenDir);
					allFunctions.push(...functions);

					for (const importStr of imports) {
						const [pathStr, funcName] = importStr.split("::");
						if (!collectedImports.has(pathStr)) {
							collectedImports.set(pathStr, new Set());
						}
						collectedImports.get(pathStr)?.add(funcName);
					}
				}
			} catch (error) {
				if (error instanceof IpcGeneratorError) {
					errors.push(error);
				} else {
					errors.push(new IpcGeneratorError(`Error processing ${filePath}: ${error}`, filePath));
				}
			}
		}),
	);

	if (errors.length > 0) {
		console.error(`\n⚠️  Found ${errors.length} error(s):`);
		for (const err of errors) {
			console.error(`  - ${err.message}`);
		}
		console.error("");
	}

	allFunctions.sort((a, b) => a.channelName.localeCompare(b.channelName));
	allRegistryHandlers.sort((a, b) => a.channelName.localeCompare(b.channelName));

	const sortedPaths = Array.from(collectedImports.keys()).sort();

	await Bun.write(ipcGenFilePath, generateHandlerFile(allFunctions, collectedImports, sortedPaths));

	await Bun.write(ipcTypesFilePath, generateTypesFile(allFunctions, allRegistryHandlers, collectedImports, sortedPaths));

	if (errors.length > 0) {
		console.log(`   - ${errors.length} errors encountered`);
	}
}

if (import.meta.main) {
	genIpcHandlers();
}